const vscode = require("vscode");
const cp = require("child_process");
const path = require("path");

function activate(context) {
  const runPythonCommand = (commandName) => {
    const editor = vscode.window.activeTextEditor;

    const selection = editor?.selection;
    const document = editor?.document;
    const selectedText = document?.getText(selection) || "";
    const fullText = document?.getText() || "";
    const language = document?.languageId || "";
    const filePath = document?.uri.fsPath || "";
    const cursorPos = selection ? { line: selection.start.line, character: selection.start.character } : null;

    const contextPayload = {
      selected_text: selectedText,
      all_text: fullText,
      language,
      file_path: filePath,
      cursor_pos: cursorPos
    };

    const scriptPath = path.join(__dirname, "main.py");
    const args = [scriptPath, commandName, JSON.stringify(contextPayload)];

    const py = cp.spawnSync("python", args, { encoding: "utf-8" });

    if (py.stderr) {
      vscode.window.showErrorMessage("[pyxend] Python stderr: " + py.stderr.trim());
      return;
    }

    let actions;
    try {
      actions = JSON.parse(py.stdout);
    } catch (e) {
      vscode.window.showErrorMessage("[pyxend] Invalid JSON from Python");
      return;
    }

    if (!Array.isArray(actions)) {
      vscode.window.showErrorMessage("[pyxend] " + (actions.error || "Unknown error"));
      return;
    }

    actions.forEach((action) => {
      const editor = vscode.window.activeTextEditor;
      const document = editor?.document;

      switch (action.action) {
        case "show_modal":
          const type = action.type || "info";
          const msg = `${action.title || "Message"}: ${action.message}`;
          if (type === "error") vscode.window.showErrorMessage(msg);
          else if (type === "warning") vscode.window.showWarningMessage(msg);
          else vscode.window.showInformationMessage(msg);
          break;

        case "replace_selected_text":
          if (!editor || !selection) return;
          editor.edit(editBuilder => {
            editBuilder.replace(selection, action.text || "");
          });
          break;

        case "insert_text":
          if (!editor) return;
          const pos = editor.selection.active;
          editor.edit(editBuilder => {
            editBuilder.insert(pos, action.text || "");
          });
          break;

        case "open_file":
          if (!action.path) return;
          vscode.workspace.openTextDocument(action.path).then(doc => {
            vscode.window.showTextDocument(doc);
          });
          break;

        case "set_cursor_pos":
          if (!editor || !action.line || !action.character) return;
          const position = new vscode.Position(action.line, action.character);
          editor.selection = new vscode.Selection(position, position);
          editor.revealRange(new vscode.Range(position, position));
          break;

        case "save_file":
          document?.save();
          break;

        case "run_terminal_command":
          const terminal = vscode.window.createTerminal(action.terminal_name || "pyxend terminal");
          terminal.show();
          terminal.sendText(action.command);
          break;

        case "overwrite_file":
          if (!editor) return;
          const entireRange = new vscode.Range(
            document.positionAt(0),
            document.positionAt(document.getText().length)
          );
          editor.edit(editBuilder => {
            editBuilder.replace(entireRange, action.text || "");
          });
          break;

        default:
          vscode.window.showWarningMessage("[pyxend] Unknown action: " + action.action);
      }
    });
  };

  context.subscriptions.push(
    {% for command in commands %}
    vscode.commands.registerCommand("{{ extension_name }}.{{ command }}", () => {
      runPythonCommand('{{ command }}');
    }),
    {% endfor %}
  );
}

function deactivate() {}

module.exports = { activate, deactivate };
